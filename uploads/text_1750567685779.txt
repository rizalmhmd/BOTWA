const fetch = require('node-fetch');
const fs = require('fs');
const path = require('path');

const GITHUB_TOKEN = global.github.rizalmhmd;
const REPO_OWNER = "rizalmhmd";
const REPO_NAME = "BOTWA";
const BRANCH = "master";

async function uploadToGitHub(destinationPath, filePath) {
 try {
 const fileContent = fs.readFileSync(filePath, { encoding: 'base64' });

 const url = `https://api.github.com/repos/${REPO_OWNER}/${REPO_NAME}/contents/${destinationPath}`;
 const payload = {
 message: `Add ${destinationPath}`,
 content: fileContent,
 branch: BRANCH,
 };

 const response = await fetch(url, {
 method: 'PUT',
 headers: {
 Authorization: `Bearer ${GITHUB_TOKEN}`,
 'Content-Type': 'application/json',
 },
 body: JSON.stringify(payload),
 });

 const data = await response.json();
 if (response.ok) {
 return `https://raw.githubusercontent.com/${REPO_OWNER}/${REPO_NAME}/${BRANCH}/${destinationPath}`;
 } else {
 throw new Error(data.message || 'Gagal mengunggah file ke GitHub.');
 }
 } catch (error) {
 throw new Error(`Error mengunggah file: ${error.message}`);
 }
}

exports.run = {
 usage: ['upgh'],
 use: 'reply file / kirim text',
 category: 'owner',
 async: async (m, { mecha, quoted, text }) => {
 mecha.sendReact(m.chat, 'ğŸ•’', m.key);

 try {
 let mediaPath, destinationPath;

 if (quoted && quoted.mime) {
 // âœ… Upload file (seperti sebelumnya)
 mediaPath = await mecha.downloadAndSaveMediaMessage(m);
 const extension = quoted.mime.split('/')[1] || 'file';
 destinationPath = `uploads/${Date.now()}.${extension}`;
 } else if (m.text) {
 // âœ… Upload teks sebagai file .txt
 const filename = `text_${Date.now()}.txt`;
 const tempPath = path.join(__dirname, filename);
 fs.writeFileSync(tempPath, m.text);
 mediaPath = tempPath;
 destinationPath = `uploads/${filename}`;
 } else {
 return m.reply(`Kirim/reply file *atau* ketik teks dengan caption *${m.cmd}*`);
 }

 const fileUrl = await uploadToGitHub(destinationPath, mediaPath);
 await mecha.reply(m.chat, `âœ… File berhasil diunggah:\n${fileUrl}`, m);

 fs.unlinkSync(mediaPath);
 } catch (e) {
 return m.reply(`âŒ Error: ${String(e)}`);
 }
 },
 owner: true
};